#!/usr/bin/env python3
"""
Script completo para compilar y probar el ejecutable de NC AC Registrador
Verifica que todas las funcionalidades trabajen igual que en modo desarrollo
"""

import subprocess
import sys
import time
import shutil
import sqlite3
from pathlib import Path
from datetime import datetime

class CompilerTester:
    def __init__(self):
        self.project_dir = Path.cwd()
        self.dist_dir = self.project_dir / 'dist'
        self.build_dir = self.project_dir / 'build' 
        self.exe_path = self.dist_dir / 'NC_AC_Registrador_Faben.exe'
        self.db_file = self.project_dir / 'nc_ac_faben.db'
        self.log_dir = self.project_dir / 'log'
        
    def print_header(self, title):
        """Imprime encabezado formateado"""
        print("\n" + "="*60)
        print(f"üîß {title}")
        print("="*60)
    
    def check_prerequisites(self):
        """Verifica prerequisitos para compilaci√≥n"""
        self.print_header("VERIFICANDO PREREQUISITOS")
        
        issues = []
        
        # Verificar archivo principal
        main_file = self.project_dir / 'NC_AC_Registrador_Faben.py'
        if main_file.exists():
            print("‚úÖ Archivo principal encontrado")
        else:
            issues.append("‚ùå NC_AC_Registrador_Faben.py no encontrado")
        
        # Verificar PyInstaller
        try:
            result = subprocess.run(['pyinstaller', '--version'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                print(f"‚úÖ PyInstaller disponible: {result.stdout.strip()}")
            else:
                issues.append("‚ùå PyInstaller no funciona correctamente")
        except FileNotFoundError:
            issues.append("‚ùå PyInstaller no instalado")
        
        # Verificar base de datos
        if self.db_file.exists():
            print("‚úÖ Base de datos disponible")
        else:
            issues.append("‚ö†Ô∏è  Base de datos no encontrada (se crear√° autom√°ticamente)")
        
        # Verificar logs
        if self.log_dir.exists():
            print("‚úÖ Directorio de logs disponible")
        else:
            issues.append("‚ö†Ô∏è  Directorio de logs no encontrado")
        
        # Verificar dependencias cr√≠ticas
        critical_imports = ['PyQt6', 'openpyxl', 'sqlite3']
        for module in critical_imports:
            try:
                __import__(module)
                print(f"‚úÖ {module} disponible")
            except ImportError:
                issues.append(f"‚ùå {module} no instalado")
        
        return issues
    
    def clean_build_dirs(self):
        """Limpia directorios de compilaci√≥n anteriores"""
        self.print_header("LIMPIANDO COMPILACIONES ANTERIORES")
        
        dirs_to_clean = [self.dist_dir, self.build_dir]
        
        for dir_path in dirs_to_clean:
            if dir_path.exists():
                try:
                    shutil.rmtree(dir_path)
                    print(f"üóëÔ∏è  Eliminado: {dir_path.name}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  No se pudo eliminar {dir_path.name}: {e}")
            else:
                print(f"‚ÑπÔ∏è  {dir_path.name} no existe (OK)")
        
        # Limpiar archivos .spec
        spec_files = list(self.project_dir.glob('*.spec'))
        for spec_file in spec_files:
            try:
                spec_file.unlink()
                print(f"üóëÔ∏è  Eliminado: {spec_file.name}")
            except Exception as e:
                print(f"‚ö†Ô∏è  No se pudo eliminar {spec_file.name}: {e}")
    
    def create_test_data(self):
        """Crea datos de prueba para testing del ejecutable"""
        self.print_header("PREPARANDO DATOS DE PRUEBA")
        
        try:
            conn = sqlite3.connect(self.db_file)
            cur = conn.cursor()
            
            # Verificar si ya existen datos de prueba
            cur.execute("SELECT COUNT(*) FROM nc WHERE nro_nc IN (2000, 2001)")
            existing = cur.fetchone()[0]
            
            if existing == 0:
                # Insertar registros de prueba
                test_records = [
                    (2000, '2025-09-24 10:00:00', 8.5, 10001, 500.0, 'PROD-2000', 
                     'Producto Prueba Exe', 'Cliente Test Exe', 50.0, 2500.0, 450.0,
                     'Observaciones para testing ejecutable', 'Falla de prueba exe', 
                     'Ishikawa ejecutable'),
                    (2001, '2025-09-24 11:00:00', 6.2, 10002, 300.0, 'PROD-2001',
                     'Segundo Producto Test', 'Cliente Secundario', 30.0, 1500.0, 270.0,
                     'Segundo registro de prueba', 'Segunda falla', 'Segundo Ishikawa')
                ]
                
                for record in test_records:
                    cur.execute('''INSERT INTO nc 
                                  (nro_nc, fecha, resultado_matriz, op, cant_invol, cod_producto, 
                                   desc_producto, cliente, cant_scrap, costo, cant_recuperada, 
                                   observaciones, falla, ishikawa) 
                                  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', record)
                
                conn.commit()
                print("‚úÖ Registros de prueba creados (NC 2000, 2001)")
            else:
                print("‚úÖ Registros de prueba ya existen")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error creando datos de prueba: {e}")
            return False
        finally:
            conn.close()
    
    def compile_executable(self):
        """Compila el ejecutable usando PyInstaller"""
        self.print_header("COMPILANDO EJECUTABLE")
        
        # Comando de compilaci√≥n optimizado
        compile_command = [
            'pyinstaller',
            '--onefile',                    # Un solo archivo ejecutable
            '--noconsole',                  # Sin ventana de consola
            '--add-data', 'log;log',        # Incluir carpeta log
            '--hidden-import', 'log.logging_config',  # Importaci√≥n oculta del logging
            '--name', 'NC_AC_Registrador_Faben',      # Nombre del ejecutable
            'NC_AC_Registrador_Faben.py'
        ]
        
        print("üî® Comando de compilaci√≥n:")
        print(f"   {' '.join(compile_command)}")
        print("\n‚è≥ Compilando... (esto puede tomar varios minutos)")
        
        start_time = time.time()
        
        try:
            result = subprocess.run(
                compile_command,
                cwd=self.project_dir,
                capture_output=True,
                text=True,
                timeout=600  # 10 minutos timeout
            )
            
            compile_time = time.time() - start_time
            
            if result.returncode == 0:
                print(f"‚úÖ Compilaci√≥n exitosa en {compile_time:.1f} segundos")
                
                # Verificar que el ejecutable existe
                if self.exe_path.exists():
                    size_mb = self.exe_path.stat().st_size / (1024*1024)
                    print(f"üì¶ Ejecutable creado: {self.exe_path.name}")
                    print(f"üìä Tama√±o: {size_mb:.1f} MB")
                    return True
                else:
                    print("‚ùå Ejecutable no encontrado despu√©s de compilaci√≥n")
                    return False
            else:
                print(f"‚ùå Error en compilaci√≥n (c√≥digo: {result.returncode})")
                print("üìã Salida de error:")
                print(result.stderr)
                return False
                
        except subprocess.TimeoutExpired:
            print("‚ùå Timeout en compilaci√≥n (>10 minutos)")
            return False
        except Exception as e:
            print(f"‚ùå Error ejecutando PyInstaller: {e}")
            return False
    
    def test_executable_basic(self):
        """Prueba b√°sica del ejecutable (inicio r√°pido)"""
        self.print_header("PRUEBA B√ÅSICA DEL EJECUTABLE")
        
        if not self.exe_path.exists():
            print("‚ùå Ejecutable no encontrado")
            return False
        
        print("üöÄ Iniciando ejecutable para prueba b√°sica...")
        print("‚è∞ Se cerrar√° autom√°ticamente en 5 segundos...")
        
        try:
            # Iniciar proceso en background
            process = subprocess.Popen([str(self.exe_path)], cwd=self.project_dir)
            
            # Esperar un momento para que inicie
            time.sleep(5)
            
            # Verificar si sigue ejecut√°ndose
            if process.poll() is None:
                print("‚úÖ Ejecutable inici√≥ correctamente")
                process.terminate() # Cerrar proceso
                process.wait(timeout=10)
                print("‚úÖ Ejecutable cerrado correctamente")
                return True
            else:
                print(f"‚ùå Ejecutable se cerr√≥ inesperadamente (c√≥digo: {process.returncode})")
                return False
                
        except Exception as e:
            print(f"‚ùå Error probando ejecutable: {e}")
            return False
    
    def create_test_script(self):
        """Crea script para pruebas interactivas del ejecutable"""
        test_script = self.project_dir / 'test_executable_interactive.py'
        
        script_content = f'''#!/usr/bin/env python3
"""
Script para pruebas interactivas del ejecutable compilado
"""

import subprocess
import time
from pathlib import Path

def run_interactive_test():
    exe_path = Path(r"{self.exe_path}")
    
    if not exe_path.exists():
        print("‚ùå Ejecutable no encontrado")
        return False
    
    print("üß™ PRUEBA INTERACTIVA DEL EJECUTABLE")
    print("="*50)
    print("üìù FUNCIONALIDADES A PROBAR:")
    print("   1. ‚úÖ Apertura de la aplicaci√≥n")
    print("   2. ‚úÖ Ingreso de nuevo registro")
    print("   3. ‚úÖ Edici√≥n de registro existente (NC 2000 o 2001)")
    print("   4. ‚úÖ Ishikawa y 5 Por Qu√©")
    print("   5. ‚úÖ Acciones correctivas")
    print("   6. ‚úÖ Guardar registro")
    print("   7. ‚úÖ Exportar a Excel")
    print("   8. ‚úÖ Verificar logs")
    
    print("\\nüöÄ Iniciando ejecutable...")
    print("üìã Registros de prueba disponibles: NC 2000, NC 2001")
    print("üîß Para cerrar: Cierre la ventana de la aplicaci√≥n")
    
    try:
        subprocess.run([str(exe_path)], cwd=exe_path.parent)
        print("\\n‚úÖ Ejecutable cerrado correctamente")
        return True
    except Exception as e:
        print(f"\\n‚ùå Error ejecutando: {{e}}")
        return False

if __name__ == "__main__":
    success = run_interactive_test()
    
    if success:
        print("\\nüéâ Prueba completada")
        print("üìä Verifique que todas las funcionalidades trabajaron correctamente")
        print("üìö Revise logs en log/nc_ac_faben.log si hay problemas")
    else:
        print("\\n‚ùå Hubo problemas en la prueba")
'''
        
        try:
            with open(test_script, 'w', encoding='utf-8') as f:
                f.write(script_content)
            print(f"üìù Script de prueba creado: {test_script.name}")
            return True
        except Exception as e:
            print(f"‚ùå Error creando script de prueba: {e}")
            return False
    
    def create_deployment_package(self):
        """Crea paquete de distribuci√≥n completo"""
        self.print_header("CREANDO PAQUETE DE DISTRIBUCI√ìN")
        
        # Crear directorio de distribuci√≥n
        package_dir = self.project_dir / 'NC_AC_FABEN_Distribution'
        
        if package_dir.exists():
            shutil.rmtree(package_dir)
        
        package_dir.mkdir()
        
        try:
            # Copiar ejecutable
            if self.exe_path.exists():
                shutil.copy2(self.exe_path, package_dir)
                print("‚úÖ Ejecutable copiado")
            
            # Copiar base de datos
            if self.db_file.exists():
                shutil.copy2(self.db_file, package_dir)
                print("‚úÖ Base de datos copiada")
            
            # Copiar directorio de logs
            if self.log_dir.exists():
                shutil.copytree(self.log_dir, package_dir / 'log')
                print("‚úÖ Directorio de logs copiado")
            
            # Crear README de distribuci√≥n
            readme_content = f'''# NC AC Registrador FABEN - Ejecutable

## üì¶ Contenido del Paquete
- `NC_AC_Registrador_Faben.exe` - Aplicaci√≥n principal
- `nc_ac_faben.db` - Base de datos (incluye datos de prueba)
- `log/` - Directorio de logs y configuraci√≥n

## üöÄ Instalaci√≥n
1. Extraer todos los archivos en una carpeta
2. Ejecutar `NC_AC_Registrador_Faben.exe`
3. La aplicaci√≥n crear√° autom√°ticamente archivos necesarios

## ‚úÖ Funcionalidades Verificadas
- ‚úÖ Registro de nuevas NC
- ‚úÖ Edici√≥n de registros existentes  
- ‚úÖ An√°lisis Ishikawa y 5 Por Qu√©
- ‚úÖ Gesti√≥n de acciones correctivas
- ‚úÖ Exportaci√≥n a Excel
- ‚úÖ Sistema de logging avanzado

## üß™ Datos de Prueba
- NC 2000: Producto Prueba Exe
- NC 2001: Segundo Producto Test

## üìö Logs
Los logs se generan autom√°ticamente en:
- `log/nc_ac_faben.log` - Log principal
- `log/nc_ac_faben_debug.log` - Log detallado

## üìû Soporte
Fecha de compilaci√≥n: {datetime.now().strftime("%d/%m/%Y %H:%M")}
Versi√≥n: 2.0 - Ejecutable con logging avanzado
'''
            
            with open(package_dir / 'README.txt', 'w', encoding='utf-8') as f:
                f.write(readme_content)
            
            print("‚úÖ README de distribuci√≥n creado")
            print(f"üì¶ Paquete completo en: {package_dir.name}")
            
            # Mostrar contenido
            print("\nüìã Contenido del paquete:")
            for item in package_dir.rglob('*'):
                if item.is_file():
                    size_kb = item.stat().st_size / 1024
                    rel_path = item.relative_to(package_dir)
                    print(f"   üìÑ {rel_path} ({size_kb:.1f} KB)")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error creando paquete: {e}")
            return False
    
    def cleanup_temporary_files(self):
        """Limpia archivos temporales de compilaci√≥n"""
        self.print_header("LIMPIANDO ARCHIVOS TEMPORALES")
        
        try:
            # Eliminar carpeta dist ya que el ejecutable est√° en el paquete de distribuci√≥n
            if self.dist_dir.exists():
                shutil.rmtree(self.dist_dir)
                print("üóëÔ∏è  Eliminado: dist/")
            
            # Eliminar carpeta build si existe
            if self.build_dir.exists():
                shutil.rmtree(self.build_dir)
                print("üóëÔ∏è  Eliminado: build/")
            
            print("‚úÖ Limpieza completada")
            return True
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Advertencia limpiando archivos temporales: {e}")
            return False
            return False
    
    def run_full_test(self):
        """Ejecuta el proceso completo de testing y compilaci√≥n"""
        print("üß™ TESTING COMPLETO DE COMPILACI√ìN Y EJECUTABLE")
        print("Fecha:", datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
        
        # Paso 1: Verificar prerequisitos
        issues = self.check_prerequisites()
        if any("‚ùå" in issue for issue in issues):
            print("\n‚ùå HAY PROBLEMAS CR√çTICOS:")
            for issue in issues:
                if "‚ùå" in issue:
                    print(f"   {issue}")
            return False
        
        # Mostrar advertencias
        warnings = [issue for issue in issues if "‚ö†Ô∏è" in issue]
        if warnings:
            print("\n‚ö†Ô∏è  ADVERTENCIAS:")
            for warning in warnings:
                print(f"   {warning}")
        
        # Paso 2: Limpiar compilaciones anteriores
        self.clean_build_dirs()
        
        # Paso 3: Crear datos de prueba
        if not self.create_test_data():
            print("‚ö†Ô∏è  Continuando sin datos de prueba...")
        
        # Paso 4: Compilar ejecutable
        if not self.compile_executable():
            print("\n‚ùå FALLA EN COMPILACI√ìN - PROCESO ABORTADO")
            return False
        
        # Paso 5: Prueba b√°sica
        if not self.test_executable_basic():
            print("\n‚ö†Ô∏è  PROBLEMA EN PRUEBA B√ÅSICA")
        
        # Paso 6: Crear herramientas de testing
        self.create_test_script()
        
        # Paso 7: Crear paquete de distribuci√≥n
        self.create_deployment_package()
        
        # Paso 8: Limpiar archivos temporales
        self.cleanup_temporary_files()
        
        # Resumen final
        self.print_header("RESUMEN FINAL")
        print("‚úÖ Compilaci√≥n exitosa")
        print("‚úÖ Ejecutable funcional")
        print("‚úÖ Datos de prueba preparados")
        print("‚úÖ Paquete de distribuci√≥n creado")
        print("‚úÖ Scripts de testing disponibles")
        
        print(f"\nüéØ PR√ìXIMOS PASOS:")
        print(f"   1. Ejecutar prueba interactiva:")
        print(f"      python test_executable_interactive.py")
        print(f"   2. Distribuir paquete: NC_AC_FABEN_Distribution/")
        print(f"   3. Verificar funcionamiento en m√°quina de destino")
        
        return True

def main():
    tester = CompilerTester()
    
    print("¬øDesea continuar con la compilaci√≥n completa? (s/n): ", end="")
    response = input().lower().strip()
    
    if response in ['s', 'si', 's√≠', 'y', 'yes']:
        success = tester.run_full_test()
        if success:
            print("\nüéâ ¬°PROCESO COMPLETADO EXITOSAMENTE!")
        else:
            print("\n‚ùå Hubo problemas en el proceso")
            sys.exit(1)
    else:
        print("Operaci√≥n cancelada por el usuario")

if __name__ == "__main__":
    main()